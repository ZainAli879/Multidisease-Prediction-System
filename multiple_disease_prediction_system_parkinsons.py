# -*- coding: utf-8 -*-
"""Multiple_disease_prediction_system_parkinsons.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HLUhCiYeiVTxCPOjPYzat1T1T2SJjjNd

**Importing the Dependencies**
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split,GridSearchCV
from sklearn import svm
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score

from google.colab import drive
drive.mount('/content/drive')

"""# Data Collection

PIMA Diabetes Dataset
"""

# loading the data from csv file to a Pandas DataFrame
parkinsons_data = pd.read_csv('/content/drive/MyDrive/Multidisease_datasets/parkinsons.csv')

# printing the first 5 rows of the dataset
parkinsons_data.head()

"""# Data Exploration and Understanding"""

# number of rows and Columns in this dataset
parkinsons_data.shape

#Frequency distribution of status variable
#Number of instances(rows) that belong to each class
#Size() is used for displaying number of rows associated with each value of target variable
parkinsons_data.groupby('status').size()

# getting the statistical measures of the data
parkinsons_data.describe()

parkinsons_data['status'].value_counts()

"""0 --> No Parkinsons

1 --> Have Parkinsons
"""

#Visualizing the frequency distribution
f, ax = plt.subplots(figsize=(8,6))
ax = sns.countplot(x="status", data=parkinsons_data)
plt.show

parkinsons_data=parkinsons_data.drop(columns=['name'],axis=1)
parkinsons_data.head()

#Corelation between features and target
correlations = parkinsons_data.corr()
print(correlations["status"].sort_values(ascending=False)) # Assuming you want to sort in descending order

#Frequency distribution of target variable w.r.t different features
parkinsons_data.groupby('spread1')['status'].value_counts()

#Visualizing count of the 'Pregnencies' variable w.r.t target
f, ax = plt.subplots(figsize=(8,6))
ax = sns.countplot(x="spread1", hue="status", data= parkinsons_data)
plt.show()

"""# Findings of the univariate analysis"""

# getting the statistical measures of the data
parkinsons_data.describe()

# getting information about features and their datatypes
parkinsons_data.info()

#Analyzing the status Variable
parkinsons_data["status"].describe()

"""#Bivariate Analysis"""

#Corelation between features and target
correlations = parkinsons_data.corr()
print(correlations["status"].sort_values(ascending=False)) # Assuming you want to sort in descending order

#Analysis of Glucose and target variable
parkinsons_data['PPE'].nunique()

#Freuency distribution of Glucose
parkinsons_data['PPE'].value_counts()

#Visualize the frequency distribution
f, ax = plt.subplots(figsize=(100,10))
ax = sns.countplot(x="PPE", data=parkinsons_data)
plt.show()

#Frequency distribution of target vaiable w.r.t Glucose
parkinsons_data.groupby('PPE')['status'].value_counts()

#Analysis of BMI and target variable
parkinsons_data['MDVP:Shimmer'].nunique()

#Visualize the frequency distribution
f, ax = plt.subplots(figsize=(118,10))
ax = sns.countplot(x="MDVP:Shimmer", data=parkinsons_data)
plt.show()

#Freuency distribution of BMI
parkinsons_data['MDVP:Shimmer'].value_counts()

#Frequency distribution of target vaiable w.r.t BMI
parkinsons_data.groupby('MDVP:Shimmer')['status'].value_counts()

"""# Multivariate Analysis"""

parkinsons_data.columns

# Multivariate Analysis are performed to discover patterns and relationsip in the dataset
#Heatmap to show correlation between features vs heart---
# Compute correlation matrix
correlation_matrix = parkinsons_data[['MDVP:Fo(Hz)', 'MDVP:Fhi(Hz)', 'MDVP:Flo(Hz)', 'MDVP:Jitter(%)',
       'MDVP:Jitter(Abs)', 'MDVP:RAP', 'MDVP:PPQ', 'Jitter:DDP',
       'MDVP:Shimmer', 'MDVP:Shimmer(dB)', 'Shimmer:APQ3', 'Shimmer:APQ5',
       'MDVP:APQ', 'Shimmer:DDA', 'NHR', 'HNR', 'status', 'RPDE', 'DFA',
       'spread1', 'spread2', 'D2', 'PPE']].corr()

# Create a heatmap with annotations
fig, ax = plt.subplots(figsize=(20, 22))
sns.heatmap(correlation_matrix, cmap="coolwarm", annot=True, fmt=".2f", square=True)
plt.show()

#Analysing the sex feature
parkinsons_data["Shimmer:APQ5"].unique()

sns.histplot(parkinsons_data["Shimmer:APQ5"])

parkinsons_data["NHR"].unique()

sns.histplot(parkinsons_data["NHR"])

#Analysing the Glucose feature
parkinsons_data["HNR"].unique()

sns.histplot(parkinsons_data["HNR"])

"""# Data Cleaning"""

# Check for missing values
print(parkinsons_data.isnull().sum())

"""Our dataset is already cleaned so we dont need to apply any technique to clean our data

# Data Preprocessing

# Separating the features

Separating data into features (X) and labels (Y) is necessary for training supervised machine learning models. Features are used as input for training the model, and labels represent the desired output. This division is fundamental for the model to learn relationships between inputs and outputs during training and make predictions on new data.
"""



# separating the data and labels
X = parkinsons_data.drop(columns = 'status', axis=1)
Y = parkinsons_data['status']

print(X)

print(Y)

"""# **Train Test Split**

The train-test split is a critical step in machine learning to evaluate the performance of a model. It involves dividing the dataset into training and testing sets.

Need:
It allows us to assess how well the model generalizes to new, unseen data. Without a separate test set, the model might perform well on the data it was trained on but poorly on new data (overfitting).

train_test_split is a function of model_selection(module of Sckit-learn library)
X and y: Features and labels, respectively, representing the dataset to be split.
test_size: Specifies the proportion of the dataset to include in the test split (e.g., test_size=0.2 for 20% testing).
random_state: Sets a seed for random number generation, ensuring reproducibility.
stratify: Maintains the distribution of classes in classification tasks during the split.
"""

X_train, X_test, y_train, y_test = train_test_split(X,Y, test_size = 0.2, stratify=Y, random_state=2)

# Standardize the data
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

#Lets Compare the shape of dataset noe after spliting it in testing and training data separately
print("Shape of X_Train:"+str(X_train.shape))
print("Shape of y_Train:"+str(y_train.shape))
print("Shape of X_Test:"+str(X_test.shape))
print("Shape of Y_Test:"+str(y_test.shape))

"""# Feature Selection

Perform Cross-Validation to Find the Best Alpha

Use GridSearchCV to find the optimal
ùõº
Œ± value:
"""

# from sklearn.linear_model import Lasso
# # Define the Lasso model
#  lasso = Lasso()

# # Define the parameter grid
# alpha_values = np.logspace(-10, 1, 100)  # Search over a range of alpha values
# param_grid = {'alpha': alpha_values}

# # Perform grid search with cross-validation
# grid_search = GridSearchCV(estimator=lasso, param_grid=param_grid, scoring='neg_mean_squared_error', cv=5, verbose=1)
# grid_search.fit(X_train_scaled, y_train)

# # Get the best alpha value
# best_alpha = grid_search.best_params_['alpha']
# print(f"Best alpha value: {best_alpha}")

# # from sklearn.linear_model import Lasso

# # Standardize the data
# scaler = StandardScaler()
# X_scaled = scaler.fit_transform(X)

# # Apply Lasso regression
# lasso = Lasso(alpha= 0.021544346900318777)  # Adjust alpha for regularization strength
# lasso.fit(X_scaled, Y)

# # Get the coefficients
# coefficients = lasso.coef_

# # Select features with non-zero coefficients
# features_kept = X.columns[coefficients != 0]
# print("Features kept after Lasso regression:", features_kept)

"""# Remove redundant or irrelevant features."""

# separating the features after regularization
X = parkinsons_data.drop(columns = ['status'], axis=1)
Y = parkinsons_data['status']
X_train, X_test, y_train, y_test = train_test_split(X,Y, test_size = 0.2, stratify=Y, random_state=2)
# Standardize the data
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

"""# Training the Model

# Logistic Regression

# Hyperparameter Tuning
"""

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
# Define the parameter grid for Grid Search
param_grid = {
    'C': [0.1, 1, 10, 100],
    'solver': ['newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga'],
    'penalty': ['l2'],  # 'l1' penalty requires a solver that supports it (liblinear, saga)
    'max_iter': [100, 200, 300]
}

# Initialize the Logistic Regression classifier
log_reg = LogisticRegression()

# Initialize GridSearchCV
grid_search_log_reg = GridSearchCV(estimator=log_reg, param_grid=param_grid, scoring='accuracy', cv=5, verbose=1, n_jobs=-1)

# Fit the grid search to the training data
grid_search_log_reg.fit(X_train_scaled, y_train)

# Print the best parameters and best score
print("Best parameters found: ", grid_search_log_reg.best_params_)
print("Best accuracy score: ", grid_search_log_reg.best_score_)

# Get the best estimator from the grid search
best_log_reg = grid_search_log_reg.best_estimator_

# Evaluate the best model on the test set
y_pred_log_reg = best_log_reg.predict(X_test_scaled)

accuracy_log_reg = accuracy_score(y_test, y_pred_log_reg)
precision_log_reg = precision_score(y_test, y_pred_log_reg)
recall_log_reg = recall_score(y_test, y_pred_log_reg)
f1_log_reg = f1_score(y_test, y_pred_log_reg)

print("Test set evaluation metrics for Logistic Regression:")
print("Accuracy: ", accuracy_log_reg)
print("Precision: ", precision_log_reg)
print("Recall: ", recall_log_reg)
print("F1 Score: ", f1_log_reg)

from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc
from sklearn.metrics import accuracy_score, recall_score,f1_score,precision_score,confusion_matrix
from sklearn.model_selection import train_test_split

# 5- Model fitting
from sklearn.linear_model import LogisticRegression
lr = LogisticRegression(C= 0.1, max_iter= 100, penalty= 'l2', solver= 'newton-cg')
lr.fit(X_train_scaled,y_train)
Y_pred_lr = lr.predict(X_test_scaled)

Y_pred_lr.shape
score_lr = round(accuracy_score(Y_pred_lr,y_test)*100,2)
print("The accuracy score achieved using Logistic Regression is: "+str(score_lr))

"""# Trying with different parameters"""

lr = LogisticRegression(C= 0.01, max_iter= 200, penalty= 'l2', solver= 'saga')
lr.fit(X_train_scaled,y_train)
Y_pred_lr = lr.predict(X_test_scaled)

Y_pred_lr.shape
score_lr = round(accuracy_score(Y_pred_lr,y_test)*100,2)
print("The accuracy score achieved using Logistic Regression is: "+str(score_lr))

lr = LogisticRegression(C= 0.1, max_iter= 100, penalty= 'l2', solver= 'sag')
lr.fit(X_train_scaled,y_train)
Y_pred_lr = lr.predict(X_test_scaled)

Y_pred_lr.shape
score_lr = round(accuracy_score(Y_pred_lr,y_test)*100,2)
print("The accuracy score achieved using Logistic Regression is: "+str(score_lr))

#Confusion matrix and classification report
print(confusion_matrix(Y_pred_lr,y_test))
print(classification_report(y_test,Y_pred_lr))

"""# Support Vector Machine(SVM)

# Hyperparameter Tuning
"""

# Define the parameter grid for Grid Search
param_grid = {
    'C': [0.1, 1, 10],
    'gamma': [1, 0.1, 0.01],
    'kernel': ['linear', 'rbf']
}

# Initialize the SVM classifier
svm = SVC()

# Initialize GridSearchCV
grid_search = GridSearchCV(estimator=svm, param_grid=param_grid, scoring='accuracy', cv=5, verbose=1)

# Fit the grid search to the training data
grid_search.fit(X_train_scaled, y_train)

# Print the best parameters and best score
print("Best parameters found: ", grid_search.best_params_)
print("Best accuracy score: ", grid_search.best_score_)

# Evaluate the best model on the test set
best_svm = grid_search.best_estimator_
y_pred_svm = best_svm.predict(X_test_scaled)

accuracy = accuracy_score(y_test, y_pred_svm)
precision = precision_score(y_test, y_pred_svm)
recall = recall_score(y_test, y_pred_svm)
f1 = f1_score(y_test, y_pred_svm)

print("Test set evaluation metrics:")
print("Accuracy: ", accuracy)
print("Precision: ", precision)
print("Recall: ", recall)
print("F1 Score: ", f1)

classifier = SVC(kernel='rbf',C=100,gamma=0.01)

#training the support vector Machine Classifier
classifier.fit(X_train_scaled, y_train)

"""# Model Evaluation

Accuracy Score
"""

# accuracy score on the training data
X_train_prediction = classifier.predict(X_train_scaled)
training_data_accuracy = accuracy_score(X_train_prediction, y_train)

print('Accuracy score of the training data : ', training_data_accuracy)

# accuracy score on the test data
X_test_prediction = classifier.predict(X_test_scaled)
test_data_accuracy = accuracy_score(X_test_prediction, y_test)

print('Accuracy score of the test data : ', test_data_accuracy)

"""# Trying with different Parameters"""

classifier = SVC(kernel='rbf',C=50,gamma=0.01)
#training the support vector Machine Classifier
classifier.fit(X_train_scaled, y_train)
# accuracy score on the test data
X_test_prediction = classifier.predict(X_test_scaled)
test_data_accuracy = accuracy_score(X_test_prediction, y_test)
print('Accuracy score of the test data : ', test_data_accuracy)

classifier = SVC(kernel='poly',C=100,gamma=0.01)
#training the support vector Machine Classifier
classifier.fit(X_train_scaled, y_train)
# accuracy score on the test data
X_test_prediction = classifier.predict(X_test_scaled)
test_data_accuracy = accuracy_score(X_test_prediction, y_test)
print('Accuracy score of the test data : ', test_data_accuracy)

classifier = SVC()
#training the support vector Machine Classifier
classifier.fit(X_train_scaled, y_train)
# accuracy score on the test data
X_test_prediction = classifier.predict(X_test_scaled)
test_data_accuracy = accuracy_score(X_test_prediction, y_test)
print('Accuracy score of the test data : ', test_data_accuracy)

"""# KNearestNeighbour

# Hyperparameter Optimization
"""

from sklearn.neighbors import KNeighborsClassifier
# Define the parameter grid for Grid Search
param_grid = {
    'n_neighbors': np.arange(1, 31, 2),
    'weights': ['uniform', 'distance'],
    'metric': ['euclidean', 'manhattan', 'minkowski']
}

# Initialize the KNN classifier
knn = KNeighborsClassifier()

# Initialize GridSearchCV
grid_search = GridSearchCV(estimator=knn, param_grid=param_grid, scoring='accuracy', cv=5, verbose=1, n_jobs=-1)

# Fit the grid search to the training data
grid_search.fit(X_train_scaled, y_train)

# Print the best parameters and best score
print("Best parameters found: ", grid_search.best_params_)
print("Best accuracy score: ", grid_search.best_score_)

# Evaluate the best model on the test set
best_knn = grid_search.best_estimator_
y_pred_knn = best_knn.predict(X_test_scaled)

accuracy = accuracy_score(y_test, y_pred_knn)
precision = precision_score(y_test, y_pred_knn)
recall = recall_score(y_test, y_pred_knn)
f1 = f1_score(y_test, y_pred_knn)

print("Test set evaluation metrics:")
print("Accuracy: ", accuracy)
print("Precision: ", precision)
print("Recall: ", recall)
print("F1 Score: ", f1)

"""# Model Training using KNN"""

from sklearn.neighbors import KNeighborsClassifier
knn = KNeighborsClassifier(metric= 'manhattan', n_neighbors= 19, weights= 'distance')
knn.fit(X_train_scaled,y_train)
Y_pred_knn = knn.predict(X_test_scaled)

Y_pred_knn.shape

score_knn = round(accuracy_score(Y_pred_knn,y_test)*100,2)
print("The accuracy achieved using KNN is: "+str(score_knn)+"%")

"""# Trying with Different Hyperparameters"""

from sklearn.neighbors import KNeighborsClassifier
knn = KNeighborsClassifier(metric= 'euclidean', n_neighbors= 15, weights= 'distance')
knn.fit(X_train_scaled,y_train)
Y_pred_knn = knn.predict(X_test_scaled)
Y_pred_knn.shape
score_knn = round(accuracy_score(Y_pred_knn,y_test)*100,2)
print("The accuracy achieved using KNN is: "+str(score_knn)+"%")

from sklearn.neighbors import KNeighborsClassifier
knn = KNeighborsClassifier(metric= 'euclidean', n_neighbors= 25, weights= 'uniform')
knn.fit(X_train_scaled,y_train)
Y_pred_knn = knn.predict(X_test_scaled)
Y_pred_knn.shape
score_knn = round(accuracy_score(Y_pred_knn,y_test)*100,2)
print("The accuracy achieved using KNN is: "+str(score_knn)+"%")

from sklearn.neighbors import KNeighborsClassifier
knn = KNeighborsClassifier(metric= 'minkowski', n_neighbors= 19, weights= 'distance')
knn.fit(X_train_scaled,y_train)
Y_pred_knn = knn.predict(X_test_scaled)
Y_pred_knn.shape
score_knn = round(accuracy_score(Y_pred_knn,y_test)*100,2)
print("The accuracy achieved using KNN is: "+str(score_knn)+"%")

from sklearn.neighbors import KNeighborsClassifier
knn = KNeighborsClassifier(metric= 'euclidean', n_neighbors= 1, weights= 'uniform')
knn.fit(X_train_scaled,y_train)
Y_pred_knn = knn.predict(X_test_scaled)
Y_pred_knn.shape
score_knn = round(accuracy_score(Y_pred_knn,y_test)*100,2)
print("The accuracy achieved using KNN is: "+str(score_knn)+"%")

"""# Neural Network"""

from sklearn.neural_network import MLPClassifier
from sklearn.metrics import accuracy_score

from sklearn.neural_network import MLPClassifier
from sklearn.metrics import accuracy_score

max_accuracy = 0
best_params = None

# Define parameters to search over
hidden_layer_sizes_options = [(10,), (20,), (30,), (40,), (50,)]
activation_options = ['relu', 'tanh']
solver_options = ['adam', 'sgd']
max_iter_options = [200, 300, 400, 500, 600]

for hidden_layer_sizes in hidden_layer_sizes_options:
    for activation in activation_options:
        for solver in solver_options:
            for max_iter in max_iter_options:
                mlp = MLPClassifier(hidden_layer_sizes=hidden_layer_sizes, activation=activation, solver=solver, max_iter=max_iter, random_state=0)
                mlp.fit(X_train, y_train)
                Y_pred_mlp = mlp.predict(X_test)
                current_accuracy = round(accuracy_score(y_test, Y_pred_mlp), 2)
                if current_accuracy > max_accuracy:
                    max_accuracy = current_accuracy
                    best_params = (hidden_layer_sizes, activation, solver, max_iter)

print("Best parameters found:", best_params)
print("Best accuracy found:", max_accuracy)

# Train MLPClassifier with best parameters found
mlp = MLPClassifier(hidden_layer_sizes=(30,), activation='tanh', solver='adam', max_iter=200, random_state=0)
mlp.fit(X_train, y_train)
Y_pred_mlp = mlp.predict(X_test)

mlp_accuracy = accuracy_score(y_test, Y_pred_mlp)
print("Accuracy of MLPClassifier:", mlp_accuracy)

"""# HyperParameter Optimization"""

# Train MLPClassifier with best parameters found
mlp = MLPClassifier(hidden_layer_sizes=(40,), activation='relu', solver='sgd', max_iter=300, random_state=0)
mlp.fit(X_train, y_train)
Y_pred_mlp = mlp.predict(X_test)

mlp_accuracy = accuracy_score(y_test, Y_pred_mlp)
print("Accuracy of MLPClassifier:", mlp_accuracy)

# Train MLPClassifier with best parameters found
mlp = MLPClassifier(hidden_layer_sizes=(30,), activation='tanh', solver='adam', max_iter=200, random_state=0)
mlp.fit(X_train, y_train)
Y_pred_mlp = mlp.predict(X_test)

mlp_accuracy = accuracy_score(y_test, Y_pred_mlp)
print("Accuracy of MLPClassifier:", mlp_accuracy)

# Train MLPClassifier with best parameters found
mlp = MLPClassifier(hidden_layer_sizes=(50,), activation='tanh', solver='adam', max_iter=500, random_state=0)
mlp.fit(X_train, y_train)
Y_pred_mlp = mlp.predict(X_test)

mlp_accuracy = accuracy_score(y_test, Y_pred_mlp)
print("Accuracy of MLPClassifier:", mlp_accuracy)

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix, classification_report

# Standardize the data
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Define the models
models = {
    'SVM': SVC(kernel='linear',C=100,gamma=0.01),
    'Logistic Regression': LogisticRegression(C= 10, max_iter= 100, penalty= 'l2', solver= 'newton-cg'),
    'KNN': KNeighborsClassifier(metric= 'euclidean', n_neighbors= 10, weights= 'uniform'),
    'Neural Network': MLPClassifier(hidden_layer_sizes=(10,), activation='relu', solver='adam', max_iter=200)
}

# Train and evaluate the models
results = []
for model_name, model in models.items():
    # Train the model
    model.fit(X_train, y_train)

    # Predict on the test set
    y_pred = model.predict(X_test)

    # Evaluate the model
    accuracy = accuracy_score(y_test, y_pred)
    precision = precision_score(y_test, y_pred)
    recall = recall_score(y_test, y_pred)
    f1 = f1_score(y_test, y_pred)

    # Store the results
    results.append({
        'Model': model_name,
        'Accuracy': accuracy,
        'Precision': precision,
        'Recall': recall,
        'F1 Score': f1
    })

# Convert results to a DataFrame
results_df = pd.DataFrame(results)

# Display the results
print(results_df)

# Plot the results
results_df.set_index('Model').plot(kind='bar', figsize=(10, 6))
plt.title('Model Comparison on Diabetes Dataset')
plt.ylabel('Score')
plt.xticks(rotation=45)
plt.ylim(0, 1)
plt.legend(loc='lower right')
plt.show()

"""# Making a Predictive System"""

input_data = (113.66,130.27,100.673,0.00502,0.00004,0.00257,0.00312,0.00772,0.05279,0.476,0.02896,0.03347,0.04134
              ,0.08689,0.0369,16.747,0.625362,0.708617,-4.65489,0.304107,2.672362,0.274387)

# changing the input_data to numpy array
input_data_as_numpy_array = np.asarray(input_data)

# reshape the array as we are predicting for one instance
input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)

prediction = classifier.predict(input_data_reshaped)
print(prediction)

if (prediction[0] == 0):
  print('The person does not have parkinsons disease')
else:
  print('The person has parkinsons disease')

"""# Saving the trained model"""

import pickle

filename = 'parkinsons_model.sav'
pickle.dump(classifier, open(filename, 'wb'))

# loading the saved model
loaded_model = pickle.load(open('parkinsons_model.sav', 'rb'))

input_data = (113.66,130.27,100.673,0.00502,0.00004,0.00257,0.00312,0.00772,0.05279,0.476,0.02896,0.03347,0.04134
              ,0.08689,0.0369,16.747,0.625362,0.708617,-4.65489,0.304107,2.672362,0.274387)

# changing the input_data to numpy array
input_data_as_numpy_array = np.asarray(input_data)

# reshape the array as we are predicting for one instance
input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)

prediction = loaded_model.predict(input_data_reshaped)
print(prediction)

if (prediction[0] == 0):
  print('The person does not have parkinsons disease')
else:
  print('The person has parkinsons disease')

for column in X.columns:
  print(column)